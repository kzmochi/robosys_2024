>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
新ロボットシステム学第２回
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
python3 を前につけて.pyを実行している
インタプリタ：テキストファイルを読み込んで直接実行

./a.outのように実行したい需要がある
./hello.py
可能にする2⃣つの条件
作業１：shebang「シバン」によるインタリタの指定
作業２：実行権限の付与

作業１：インタプリタの指定
#!/usr/bin/python3
which python3 とうつと
usr/bin/python3　と応答がかえってくる
Linuxがシバンを読んでインタプリタを起動

作業２：実行権限の付与
./hellow.py 「許可がない」と怒られるのでchmodで実行権限をつける
chmod +x hello.py
mv hello.py hellow 「拡張子」をつけなくても使えるようにもなる
./hellow
明示的に./でhome dirのhelloを実行しているが
usr/binに「パスを通す」ことでhelloを探して実行してくれる
PATH=$PATH:/home/suzuki
echo $PATH で「パスが通っているか確認する」
hellow で実行可能


>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
新ロボットシステム学第３回
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
pytonのリスト表記 x = [a,b,c,d]
スライス
x[1:] 1以降
x[0::]0から1つ飛ばし(偶数)
x[1::]1から1つ飛ばし(奇数)

リスト内包
e = [ float(e) forリスト文 ]
sum(e)のように文字列を数値変換して積算

for文 やif文は括弧をつけなくて良い代わりに
インデントを揃える揃ってないとError
if 条件:
    処理
for 変数 in リスト
    処理

標準出力
コマンドの出力ファイルへの保存
「> ファイル」
出力のリダイレクトと呼ばれる

ファイルからの入力
ファイルから「< ファイル」でコマンドに渡す
sys.stdin 

|:パイプ
標準入力をstdinにパイプを使って入力する 
cat nums | stdin
処理A|処理B　処理間をパイプでつなぐ意味合い
★　特別な理由がない限りデータは標準入力から受付
引数や特定のファイルからだと、このような連携ができない

パイプの利点
横並びの数字や文字の混入に対応しなくて良い
・様々な入力に柔軟に対応しない（重要！しない）
・既存のコマンドで可能なことはプログラムしない

ROSの考え方
・入出力を厳格に
・プログラムごとに機能を分ける
・既存のプログアムを再利用しやすく

標準エラー出力
echo a | stdin > ans
ansは空のあたいになり標準出力されない。
echo a | stdin 2> error
errorには標準エラー出力結果が格納される



>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
新ロボットシステム学第４回
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
・GitとGitHub
版管理(バージョン管理)システム
・ファイルの変更履歴を管理するためのシステム
・コードや文章を書くときは必須

GitHub
・Gitを利用したサービス
「リポジトリ」のホスティングと公開、コミュニケーション
鍵の設定
・手元のPCとGitHubとの通信を暗号化するために、公開鍵をGitHubに登録
・手元のPCには秘密鍵をもっておく
$ ssh-keygen
$ ls ~/.ssh/
id_rsa, id_rsa.pub この２つのファイルがあればOK
・GitHubのHome画面からユーザーアイコン --> Setting-->SSH and GPG keys-->New SSH key
id_rsa.pubの中身をコピーして貼り付け
ファイアウォール回避の設定

リポジトリの作成
GitHub の+マークからリポジトリを作成する
ライセンスについては後述する

リポジトリを手元にコピー
リポジトリ画面の"Code"をクリックして、"SSH"を選択してURLをコピー
端末上で、git clone <コピーしたURL>

リポジトリにコードをコミット
git add stdin
git status --> add状態がわかる
git commit -m "log comment"
git log -n 1 --> 最新ログコメント

GitHubへの反映
コミットしたコマンドをGitへアップロードする
プッシュと呼ぶ --> git push

GitHubを利用した開発
・GitHubにコードをアップする利点
 >自分のコーdを紛失する可能性が極めて低い
 >自分の力を見せることが可能
 >ラズパイのソースとPCのソースのバージョン違いがなくなる
・面倒なこと
 >ライセンス等の整備
 >使えないものを置かない
・改良しようと手を加えたらコードが動かなくなる
 >GitHubに直接pushするとバグがあるとコードが使えない危険がある
 >GitHubにpushしないで放置すると作業の記録が残せない
★　ブランチを分ける

ブランチ
デフォルトはmainのみ
git branch
mainブランチに動くものをおいて、開発用のブランチを作る

devブランチでの開発
git switch -c dev
*dev --> mainブランチがコピーされ以降*がついた環境にコミットされる
main
すべてのファイルをaddするオプション
git add -A
めちゃ有能なのは、中間生成物のごみのままadd -Aしてしまっても
保存後もういちどadd -Aすると中間生成物は除外してリスト化してくれる
そのままpushしようとするとpush先がわからないと怒られる
git push --set-upstream origin dev
として明確にpush先をしていしてあげる.2回目からは指定なしでdevにpushする。
devのコミット情報をmain へ「マージ」する
git switch main --> まずはmainへ戻る

コミットグラフ
git log --graph
各コミットに「コミットハッシュ値」がついている
{ }の中にブランチ名

過去のコードの取り出し
コミットハッシュ値からロールバックできる
git switch -d 63a2660f65c2271
もしくは GitHubから直接コミット履歴をコピーする


>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
ロボットシステム学　第５回
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
著作権の主張
Copyright: 2024 Kazumichi Suzuki, all right reserved
大切なことは、いつ、誰が作ったものかを明記すること
# SPDX-FileCopyrightText: 2024 Kazumichi Suzuki(ketunii3@gmail.com)
SPDX
Software Package Data Exchange
ソフトウェアライセンスなどの書き方を統一するプロジェクト
SPDX file tags
以前は10行ほど必要だったコメントだったこれ一つでOK　★ 推奨

ソフトウェアライセンス
ライセンス：利用許諾
書いたソフトウェアを「利用」してもらうときに、著作者が発行
・利用：コードやコンパイルされたバイナリを
製品や他のリポジトリに加える行為
★ 個人的にダウンロードして使うのは「使用」で「利用」ではない

そもそもなんでコードを公開しているのか？
・使用者からのフィードバック
・自分の作品を作ったら見せたい、使ってもらいたい

著作権とライセンス
著作権 = copyright = コピーの権利（著作権者に帰属）
著作権を放棄してしまうと勝手に他の人に登録されてしまい
作者自身も触れなくなってしまう

ソフトウェアライセンスの役割
著作権を手元に残したまま、第三者にコードやバイナリを提供
・利用を原則禁止にしてしようさせるもの
・利用を許可（促進）するもの
  > オープンソースに呼ばれるソフトウェア

オープンソースのライセンスの仕組み
・統一的なライセンス
GNU General Public license/BSD license/MIT license/Apache license ...etc
自分のソフトウェアにライセンスを割り付ける（自作は困難）
・ライセンスの基本的な役割
１．免責（「利用は自己責任で」）
２．著作者に権利を残す
３．利用を促進する仕組み
４．盗用、タダ乗りを防止

オープンソースライセンスの日本語参考訳
https://licenses.opensource.jp/

リポジトリへのライセンス設定
・GPL 3.0
curl https://www.gnu.org/licenses/gpl-3.0.txt > COPYING
・BDS 3-clause
vim LICENSE --> 下記URLのCopyrightから下をコピーして貼り付け
https://opensource.org/license/bsd-3-clause


>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
ロボットシステム学　第６回
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
コマンドの正常終了・異常終了
・コマンドは人だけでなくシェルにエラーの有無を伝達
「終了ステータス」と呼ばれる整数値
$?
0 正常終了
1 軽微な問題
2 重大な問題

シェルの変数
${変数}で値に置換

コマンドの出力を変数に閉じ込める
変数名=$(コマンド)
A=$(ls)

テストコマンド
１．test 文字列A = 文字列B
２．[ 文字列A = 文字列B ]
３．[[ 文字列A = 文字列B ]]

シェルスクリプト
我々が学んでいるシェルはbash
bashのシェバンは「#!/bin/bash」--> 拡張子なし OK
chmod + x <シェルスクリプト>　--> 実行 OK

シェル関数
関数名() {}, {}の中に処理を記述
|| --> or記号
処理A || 処理B --> 処理AがFALSEの場合は処理Bを実行する
シェル関数の引数 ${1} --> 第一引数
コマンドの成功/失敗を正しくリターンしてあげる
exit ret --> 異常検出の関数内でret=1を立ててあげる

初歩的なテスト
テストとは、プログラムが意図通りに動作するかを別のプログラムを書いてテストすること
・関数やプログラムに引数で、あるいは標準入力からデータを入力
・出力を記録
・期待した出力と一致するか比較
★　面倒ですよねでも

テストがないと辛い
機能が増えてくると、最初の機能がいつのまにか使えなくなっている可能性がある
リグレッションテスト（退行テスト）
テストから境界条件を読み解けたり、I/Oの確認もできる

開発スタイル
1. こまめにテスト
2. テストに通ったらGitにコミット
3. テストに失敗して、原因不明なら前回のコミットに退却
   > git restore
4. さらに細かくテスト

リグレッションテストの書き方
シェルスクリプトを利用
  > 終了ステータスを使う点でよい

テストがうまく行かないとき
#!/bin/bash -xv
-xv を入れると処理の途中変数も含めて計算された値を出力する
終了ステータスを使う意義の１つとして
-xv でlogを見ても数百行ともなると人間の目で追えないので
ステータスを使う意義がある

標準入力出力の確認をしたいときは、null(ゴミ箱)に出力するのがおすすめ
./test.bash 2> /dev/null


>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
ロボットシステム学　第７回
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
GitHub Action
様々な環境に対応する必要がある
    > Python バージョン
    > Linux, Windows
ちゃんとテストしていると示したい

Circle CI
Travis CI
1. GitHub等にpushされたコードをテスト
    > GitHub等のページに結果が表示される
2. テストが通ったら次のアクションに

改めてテストの役割
抜け目のないテストにより
・デバッグやリリースの際の手間の削減が可能
・「動いているシステムは怖くていじられない」
「継続的インテグレーション(CI)」「継続的デリバリー(CD)」「継続的デプロイ」
CI/CDサービス
★ 「自動」でテストできることがキモ

GitHub Actions
・GitHubのCI/CDサービス
・テストのはじめ方
mkdir --p .github/workflows
workflowsのなかに.ymlのファイルを作成。ヤムルと読む。
touch xxx.yml

name: test              #name: ワークフローの名前
on: push                #on: いつこのワークフローを走らせるか
jobs:                   #走らせたい処理(ジョブ)のリスト
  test:                         #testというジョブを作る
    runs-on: ubuntu-latest      #runs-on: どの環境で動作させるか
    steps:                              #手続きの記述
    - uses: actions/checkout@v3         #uses: リポジトリのクローン先(path無し)
    - name: All test                    #name: ジョブの名前
      run: bash -x ./test.bash                  #シェアルスクリプトの実行

Github robosys_2024 リポジトリ
コミットの横に● が出現する,左クリックでdetailを選択

緑・・・success
黄・・・pemding
バツ・・・failure


READMEの整備
ソフトを使ってもらうときに最初に読んでもらうドキュメント
README.md
.md マークダウンという形式

READMEに書くこと
ユーザーが困らないように
・何をするためのソフトか
・使い方
  > ダウンロード、インストール、起動手順、簡単な例やチュートリアル
・どのような環境で使えるか
  > OS/Python verstion/他に必要なソフトやライブラリ
・テストの結果
・権利関係/謝辞
  > 著作権、ライセンス
  > 手伝ってくれた人のリストと手伝いの中身
・その他必要なこと










